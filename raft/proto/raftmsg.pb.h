// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raftmsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_raftmsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_raftmsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_raftmsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_raftmsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_raftmsg_2eproto;
namespace raft {
class AppendEntriesRequest;
struct AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesResponse;
struct AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class MemberChangeRequest;
struct MemberChangeRequestDefaultTypeInternal;
extern MemberChangeRequestDefaultTypeInternal _MemberChangeRequest_default_instance_;
class MemberChangeResponse;
struct MemberChangeResponseDefaultTypeInternal;
extern MemberChangeResponseDefaultTypeInternal _MemberChangeResponse_default_instance_;
class MembersListRequest;
struct MembersListRequestDefaultTypeInternal;
extern MembersListRequestDefaultTypeInternal _MembersListRequest_default_instance_;
class MembersListResponse;
struct MembersListResponseDefaultTypeInternal;
extern MembersListResponseDefaultTypeInternal _MembersListResponse_default_instance_;
class Peer;
struct PeerDefaultTypeInternal;
extern PeerDefaultTypeInternal _Peer_default_instance_;
class RaftMessage;
struct RaftMessageDefaultTypeInternal;
extern RaftMessageDefaultTypeInternal _RaftMessage_default_instance_;
class VoteRequest;
struct VoteRequestDefaultTypeInternal;
extern VoteRequestDefaultTypeInternal _VoteRequest_default_instance_;
class VoteResponse;
struct VoteResponseDefaultTypeInternal;
extern VoteResponseDefaultTypeInternal _VoteResponse_default_instance_;
}  // namespace raft
PROTOBUF_NAMESPACE_OPEN
template<> ::raft::AppendEntriesRequest* Arena::CreateMaybeMessage<::raft::AppendEntriesRequest>(Arena*);
template<> ::raft::AppendEntriesResponse* Arena::CreateMaybeMessage<::raft::AppendEntriesResponse>(Arena*);
template<> ::raft::LogEntry* Arena::CreateMaybeMessage<::raft::LogEntry>(Arena*);
template<> ::raft::MemberChangeRequest* Arena::CreateMaybeMessage<::raft::MemberChangeRequest>(Arena*);
template<> ::raft::MemberChangeResponse* Arena::CreateMaybeMessage<::raft::MemberChangeResponse>(Arena*);
template<> ::raft::MembersListRequest* Arena::CreateMaybeMessage<::raft::MembersListRequest>(Arena*);
template<> ::raft::MembersListResponse* Arena::CreateMaybeMessage<::raft::MembersListResponse>(Arena*);
template<> ::raft::Peer* Arena::CreateMaybeMessage<::raft::Peer>(Arena*);
template<> ::raft::RaftMessage* Arena::CreateMaybeMessage<::raft::RaftMessage>(Arena*);
template<> ::raft::VoteRequest* Arena::CreateMaybeMessage<::raft::VoteRequest>(Arena*);
template<> ::raft::VoteResponse* Arena::CreateMaybeMessage<::raft::VoteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace raft {

enum RaftState : int {
  UNKNOWN = 0,
  LEADER = 1,
  FOLLOWER = 2,
  CANDIDATE = 3,
  LEANER = 4,
  RaftState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RaftState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RaftState_IsValid(int value);
constexpr RaftState RaftState_MIN = UNKNOWN;
constexpr RaftState RaftState_MAX = LEANER;
constexpr int RaftState_ARRAYSIZE = RaftState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RaftState_descriptor();
template<typename T>
inline const std::string& RaftState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RaftState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RaftState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RaftState_descriptor(), enum_t_value);
}
inline bool RaftState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RaftState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RaftState>(
    RaftState_descriptor(), name, value);
}
enum RaftLogType : int {
  LOGTYPE_NORMAL = 0,
  LOGTYPE_ADD_NONVOTING_NODE = 1,
  LOGTYPE_ADD_NODE = 2,
  LOGTYPE_REMOVE_NODE = 3,
  LOGTYPE_PROMOTE_NODE = 4,
  RaftLogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RaftLogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RaftLogType_IsValid(int value);
constexpr RaftLogType RaftLogType_MIN = LOGTYPE_NORMAL;
constexpr RaftLogType RaftLogType_MAX = LOGTYPE_PROMOTE_NODE;
constexpr int RaftLogType_ARRAYSIZE = RaftLogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RaftLogType_descriptor();
template<typename T>
inline const std::string& RaftLogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RaftLogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RaftLogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RaftLogType_descriptor(), enum_t_value);
}
inline bool RaftLogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RaftLogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RaftLogType>(
    RaftLogType_descriptor(), name, value);
}
// ===================================================================

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit PROTOBUF_CONSTEXPR LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kTermFieldNumber = 2,
    kIndexFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 term = 2;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 index = 3;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // .raft.RaftLogType type = 1;
  void clear_type();
  ::raft::RaftLogType type() const;
  void set_type(::raft::RaftLogType value);
  private:
  ::raft::RaftLogType _internal_type() const;
  void _internal_set_type(::raft::RaftLogType value);
  public:

  // @@protoc_insertion_point(class_scope:raft.LogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint64_t term_;
  uint64_t index_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class Peer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.Peer) */ {
 public:
  inline Peer() : Peer(nullptr) {}
  ~Peer() override;
  explicit PROTOBUF_CONSTEXPR Peer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Peer(const Peer& from);
  Peer(Peer&& from) noexcept
    : Peer() {
    *this = ::std::move(from);
  }

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Peer& operator=(Peer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Peer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Peer* internal_default_instance() {
    return reinterpret_cast<const Peer*>(
               &_Peer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Peer& a, Peer& b) {
    a.Swap(&b);
  }
  inline void Swap(Peer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Peer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Peer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Peer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Peer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Peer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Peer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.Peer";
  }
  protected:
  explicit Peer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kRaftidFieldNumber = 1,
    kNodeidFieldNumber = 2,
    kPortFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 raftid = 1;
  void clear_raftid();
  int32_t raftid() const;
  void set_raftid(int32_t value);
  private:
  int32_t _internal_raftid() const;
  void _internal_set_raftid(int32_t value);
  public:

  // int32 nodeid = 2;
  void clear_nodeid();
  int32_t nodeid() const;
  void set_nodeid(int32_t value);
  private:
  int32_t _internal_nodeid() const;
  void _internal_set_nodeid(int32_t value);
  public:

  // uint32 port = 4;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // .raft.RaftState state = 5;
  void clear_state();
  ::raft::RaftState state() const;
  void set_state(::raft::RaftState value);
  private:
  ::raft::RaftState _internal_state() const;
  void _internal_set_state(::raft::RaftState value);
  public:

  // @@protoc_insertion_point(class_scope:raft.Peer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int32_t raftid_;
  int32_t nodeid_;
  uint32_t port_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class VoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.VoteRequest) */ {
 public:
  inline VoteRequest() : VoteRequest(nullptr) {}
  ~VoteRequest() override;
  explicit PROTOBUF_CONSTEXPR VoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteRequest(const VoteRequest& from);
  VoteRequest(VoteRequest&& from) noexcept
    : VoteRequest() {
    *this = ::std::move(from);
  }

  inline VoteRequest& operator=(const VoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteRequest& operator=(VoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteRequest* internal_default_instance() {
    return reinterpret_cast<const VoteRequest*>(
               &_VoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VoteRequest& a, VoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.VoteRequest";
  }
  protected:
  explicit VoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kCandidateFieldNumber = 2,
    kLastTermFieldNumber = 3,
    kLastIndexFieldNumber = 4,
  };
  // uint64 term = 1;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 candidate = 2;
  void clear_candidate();
  uint64_t candidate() const;
  void set_candidate(uint64_t value);
  private:
  uint64_t _internal_candidate() const;
  void _internal_set_candidate(uint64_t value);
  public:

  // uint64 last_term = 3;
  void clear_last_term();
  uint64_t last_term() const;
  void set_last_term(uint64_t value);
  private:
  uint64_t _internal_last_term() const;
  void _internal_set_last_term(uint64_t value);
  public:

  // uint64 last_index = 4;
  void clear_last_index();
  uint64_t last_index() const;
  void set_last_index(uint64_t value);
  private:
  uint64_t _internal_last_index() const;
  void _internal_set_last_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:raft.VoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t term_;
  uint64_t candidate_;
  uint64_t last_term_;
  uint64_t last_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class VoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.VoteResponse) */ {
 public:
  inline VoteResponse() : VoteResponse(nullptr) {}
  ~VoteResponse() override;
  explicit PROTOBUF_CONSTEXPR VoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteResponse(const VoteResponse& from);
  VoteResponse(VoteResponse&& from) noexcept
    : VoteResponse() {
    *this = ::std::move(from);
  }

  inline VoteResponse& operator=(const VoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteResponse& operator=(VoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteResponse* internal_default_instance() {
    return reinterpret_cast<const VoteResponse*>(
               &_VoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VoteResponse& a, VoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.VoteResponse";
  }
  protected:
  explicit VoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kNodeidFieldNumber = 2,
    kAgreeFieldNumber = 3,
  };
  // uint64 term = 1;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // int32 nodeid = 2;
  void clear_nodeid();
  int32_t nodeid() const;
  void set_nodeid(int32_t value);
  private:
  int32_t _internal_nodeid() const;
  void _internal_set_nodeid(int32_t value);
  public:

  // bool agree = 3;
  void clear_agree();
  bool agree() const;
  void set_agree(bool value);
  private:
  bool _internal_agree() const;
  void _internal_set_agree(bool value);
  public:

  // @@protoc_insertion_point(class_scope:raft.VoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t term_;
  int32_t nodeid_;
  bool agree_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.AppendEntriesRequest) */ {
 public:
  inline AppendEntriesRequest() : AppendEntriesRequest(nullptr) {}
  ~AppendEntriesRequest() override;
  explicit PROTOBUF_CONSTEXPR AppendEntriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesRequest(const AppendEntriesRequest& from);
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntriesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.AppendEntriesRequest";
  }
  protected:
  explicit AppendEntriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 6,
    kTermFieldNumber = 2,
    kCommitFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kPrevLogIndexFieldNumber = 5,
    kNodeidFieldNumber = 1,
  };
  // repeated .raft.LogEntry entries = 6;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::raft::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::LogEntry >*
      mutable_entries();
  private:
  const ::raft::LogEntry& _internal_entries(int index) const;
  ::raft::LogEntry* _internal_add_entries();
  public:
  const ::raft::LogEntry& entries(int index) const;
  ::raft::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::LogEntry >&
      entries() const;

  // uint64 term = 2;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 commit = 3;
  void clear_commit();
  uint64_t commit() const;
  void set_commit(uint64_t value);
  private:
  uint64_t _internal_commit() const;
  void _internal_set_commit(uint64_t value);
  public:

  // uint64 prev_log_term = 4;
  void clear_prev_log_term();
  uint64_t prev_log_term() const;
  void set_prev_log_term(uint64_t value);
  private:
  uint64_t _internal_prev_log_term() const;
  void _internal_set_prev_log_term(uint64_t value);
  public:

  // uint64 prev_log_index = 5;
  void clear_prev_log_index();
  uint64_t prev_log_index() const;
  void set_prev_log_index(uint64_t value);
  private:
  uint64_t _internal_prev_log_index() const;
  void _internal_set_prev_log_index(uint64_t value);
  public:

  // int32 nodeid = 1;
  void clear_nodeid();
  int32_t nodeid() const;
  void set_nodeid(int32_t value);
  private:
  int32_t _internal_nodeid() const;
  void _internal_set_nodeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:raft.AppendEntriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::LogEntry > entries_;
  uint64_t term_;
  uint64_t commit_;
  uint64_t prev_log_term_;
  uint64_t prev_log_index_;
  int32_t nodeid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.AppendEntriesResponse) */ {
 public:
  inline AppendEntriesResponse() : AppendEntriesResponse(nullptr) {}
  ~AppendEntriesResponse() override;
  explicit PROTOBUF_CONSTEXPR AppendEntriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesResponse(const AppendEntriesResponse& from);
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntriesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.AppendEntriesResponse";
  }
  protected:
  explicit AppendEntriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kNodeidFieldNumber = 2,
    kTermFieldNumber = 3,
    kCurrentIndexFieldNumber = 4,
    kFirstIndexFieldNumber = 5,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 nodeid = 2;
  void clear_nodeid();
  int32_t nodeid() const;
  void set_nodeid(int32_t value);
  private:
  int32_t _internal_nodeid() const;
  void _internal_set_nodeid(int32_t value);
  public:

  // uint64 term = 3;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 current_index = 4;
  void clear_current_index();
  uint64_t current_index() const;
  void set_current_index(uint64_t value);
  private:
  uint64_t _internal_current_index() const;
  void _internal_set_current_index(uint64_t value);
  public:

  // uint64 first_index = 5;
  void clear_first_index();
  uint64_t first_index() const;
  void set_first_index(uint64_t value);
  private:
  uint64_t _internal_first_index() const;
  void _internal_set_first_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:raft.AppendEntriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  int32_t nodeid_;
  uint64_t term_;
  uint64_t current_index_;
  uint64_t first_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class MemberChangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.MemberChangeRequest) */ {
 public:
  inline MemberChangeRequest() : MemberChangeRequest(nullptr) {}
  ~MemberChangeRequest() override;
  explicit PROTOBUF_CONSTEXPR MemberChangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberChangeRequest(const MemberChangeRequest& from);
  MemberChangeRequest(MemberChangeRequest&& from) noexcept
    : MemberChangeRequest() {
    *this = ::std::move(from);
  }

  inline MemberChangeRequest& operator=(const MemberChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberChangeRequest& operator=(MemberChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberChangeRequest* internal_default_instance() {
    return reinterpret_cast<const MemberChangeRequest*>(
               &_MemberChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MemberChangeRequest& a, MemberChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberChangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberChangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberChangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemberChangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberChangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.MemberChangeRequest";
  }
  protected:
  explicit MemberChangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .raft.Peer peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::raft::Peer& peer() const;
  PROTOBUF_NODISCARD ::raft::Peer* release_peer();
  ::raft::Peer* mutable_peer();
  void set_allocated_peer(::raft::Peer* peer);
  private:
  const ::raft::Peer& _internal_peer() const;
  ::raft::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::raft::Peer* peer);
  ::raft::Peer* unsafe_arena_release_peer();

  // .raft.RaftLogType type = 1;
  void clear_type();
  ::raft::RaftLogType type() const;
  void set_type(::raft::RaftLogType value);
  private:
  ::raft::RaftLogType _internal_type() const;
  void _internal_set_type(::raft::RaftLogType value);
  public:

  // @@protoc_insertion_point(class_scope:raft.MemberChangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::raft::Peer* peer_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class MemberChangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.MemberChangeResponse) */ {
 public:
  inline MemberChangeResponse() : MemberChangeResponse(nullptr) {}
  ~MemberChangeResponse() override;
  explicit PROTOBUF_CONSTEXPR MemberChangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberChangeResponse(const MemberChangeResponse& from);
  MemberChangeResponse(MemberChangeResponse&& from) noexcept
    : MemberChangeResponse() {
    *this = ::std::move(from);
  }

  inline MemberChangeResponse& operator=(const MemberChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberChangeResponse& operator=(MemberChangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberChangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberChangeResponse* internal_default_instance() {
    return reinterpret_cast<const MemberChangeResponse*>(
               &_MemberChangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MemberChangeResponse& a, MemberChangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberChangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberChangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberChangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberChangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberChangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemberChangeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberChangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.MemberChangeResponse";
  }
  protected:
  explicit MemberChangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 3,
    kTermFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .raft.Peer peer = 3;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::raft::Peer& peer() const;
  PROTOBUF_NODISCARD ::raft::Peer* release_peer();
  ::raft::Peer* mutable_peer();
  void set_allocated_peer(::raft::Peer* peer);
  private:
  const ::raft::Peer& _internal_peer() const;
  ::raft::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::raft::Peer* peer);
  ::raft::Peer* unsafe_arena_release_peer();

  // uint64 term = 2;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:raft.MemberChangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::raft::Peer* peer_;
  uint64_t term_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class MembersListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.MembersListRequest) */ {
 public:
  inline MembersListRequest() : MembersListRequest(nullptr) {}
  ~MembersListRequest() override;
  explicit PROTOBUF_CONSTEXPR MembersListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MembersListRequest(const MembersListRequest& from);
  MembersListRequest(MembersListRequest&& from) noexcept
    : MembersListRequest() {
    *this = ::std::move(from);
  }

  inline MembersListRequest& operator=(const MembersListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MembersListRequest& operator=(MembersListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MembersListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MembersListRequest* internal_default_instance() {
    return reinterpret_cast<const MembersListRequest*>(
               &_MembersListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MembersListRequest& a, MembersListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MembersListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MembersListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MembersListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MembersListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MembersListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MembersListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MembersListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.MembersListRequest";
  }
  protected:
  explicit MembersListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaftidFieldNumber = 1,
  };
  // uint64 raftid = 1;
  void clear_raftid();
  uint64_t raftid() const;
  void set_raftid(uint64_t value);
  private:
  uint64_t _internal_raftid() const;
  void _internal_set_raftid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:raft.MembersListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t raftid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class MembersListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.MembersListResponse) */ {
 public:
  inline MembersListResponse() : MembersListResponse(nullptr) {}
  ~MembersListResponse() override;
  explicit PROTOBUF_CONSTEXPR MembersListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MembersListResponse(const MembersListResponse& from);
  MembersListResponse(MembersListResponse&& from) noexcept
    : MembersListResponse() {
    *this = ::std::move(from);
  }

  inline MembersListResponse& operator=(const MembersListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MembersListResponse& operator=(MembersListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MembersListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MembersListResponse* internal_default_instance() {
    return reinterpret_cast<const MembersListResponse*>(
               &_MembersListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MembersListResponse& a, MembersListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MembersListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MembersListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MembersListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MembersListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MembersListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MembersListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MembersListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.MembersListResponse";
  }
  protected:
  explicit MembersListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 4,
    kTermFieldNumber = 2,
    kRaftidFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .raft.Peer peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::raft::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::Peer >*
      mutable_peers();
  private:
  const ::raft::Peer& _internal_peers(int index) const;
  ::raft::Peer* _internal_add_peers();
  public:
  const ::raft::Peer& peers(int index) const;
  ::raft::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::Peer >&
      peers() const;

  // uint64 term = 2;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 raftid = 3;
  void clear_raftid();
  uint64_t raftid() const;
  void set_raftid(uint64_t value);
  private:
  uint64_t _internal_raftid() const;
  void _internal_set_raftid(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:raft.MembersListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::Peer > peers_;
  uint64_t term_;
  uint64_t raftid_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raftmsg_2eproto;
};
// -------------------------------------------------------------------

class RaftMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:raft.RaftMessage) */ {
 public:
  inline RaftMessage() : RaftMessage(nullptr) {}
  ~RaftMessage() override;
  explicit PROTOBUF_CONSTEXPR RaftMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftMessage(const RaftMessage& from);
  RaftMessage(RaftMessage&& from) noexcept
    : RaftMessage() {
    *this = ::std::move(from);
  }

  inline RaftMessage& operator=(const RaftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftMessage& operator=(RaftMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kVtReq = 2,
    kVtRsp = 3,
    kAeReq = 4,
    kAeRsp = 5,
    kMcReq = 6,
    kMcRsp = 7,
    kMlReq = 8,
    kMlRsp = 9,
    MSG_NOT_SET = 0,
  };

  static inline const RaftMessage* internal_default_instance() {
    return reinterpret_cast<const RaftMessage*>(
               &_RaftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RaftMessage& a, RaftMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "raft.RaftMessage";
  }
  protected:
  explicit RaftMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaftidFieldNumber = 1,
    kVtReqFieldNumber = 2,
    kVtRspFieldNumber = 3,
    kAeReqFieldNumber = 4,
    kAeRspFieldNumber = 5,
    kMcReqFieldNumber = 6,
    kMcRspFieldNumber = 7,
    kMlReqFieldNumber = 8,
    kMlRspFieldNumber = 9,
  };
  // uint32 raftid = 1;
  void clear_raftid();
  uint32_t raftid() const;
  void set_raftid(uint32_t value);
  private:
  uint32_t _internal_raftid() const;
  void _internal_set_raftid(uint32_t value);
  public:

  // .raft.VoteRequest vt_req = 2;
  bool has_vt_req() const;
  private:
  bool _internal_has_vt_req() const;
  public:
  void clear_vt_req();
  const ::raft::VoteRequest& vt_req() const;
  PROTOBUF_NODISCARD ::raft::VoteRequest* release_vt_req();
  ::raft::VoteRequest* mutable_vt_req();
  void set_allocated_vt_req(::raft::VoteRequest* vt_req);
  private:
  const ::raft::VoteRequest& _internal_vt_req() const;
  ::raft::VoteRequest* _internal_mutable_vt_req();
  public:
  void unsafe_arena_set_allocated_vt_req(
      ::raft::VoteRequest* vt_req);
  ::raft::VoteRequest* unsafe_arena_release_vt_req();

  // .raft.VoteResponse vt_rsp = 3;
  bool has_vt_rsp() const;
  private:
  bool _internal_has_vt_rsp() const;
  public:
  void clear_vt_rsp();
  const ::raft::VoteResponse& vt_rsp() const;
  PROTOBUF_NODISCARD ::raft::VoteResponse* release_vt_rsp();
  ::raft::VoteResponse* mutable_vt_rsp();
  void set_allocated_vt_rsp(::raft::VoteResponse* vt_rsp);
  private:
  const ::raft::VoteResponse& _internal_vt_rsp() const;
  ::raft::VoteResponse* _internal_mutable_vt_rsp();
  public:
  void unsafe_arena_set_allocated_vt_rsp(
      ::raft::VoteResponse* vt_rsp);
  ::raft::VoteResponse* unsafe_arena_release_vt_rsp();

  // .raft.AppendEntriesRequest ae_req = 4;
  bool has_ae_req() const;
  private:
  bool _internal_has_ae_req() const;
  public:
  void clear_ae_req();
  const ::raft::AppendEntriesRequest& ae_req() const;
  PROTOBUF_NODISCARD ::raft::AppendEntriesRequest* release_ae_req();
  ::raft::AppendEntriesRequest* mutable_ae_req();
  void set_allocated_ae_req(::raft::AppendEntriesRequest* ae_req);
  private:
  const ::raft::AppendEntriesRequest& _internal_ae_req() const;
  ::raft::AppendEntriesRequest* _internal_mutable_ae_req();
  public:
  void unsafe_arena_set_allocated_ae_req(
      ::raft::AppendEntriesRequest* ae_req);
  ::raft::AppendEntriesRequest* unsafe_arena_release_ae_req();

  // .raft.AppendEntriesResponse ae_rsp = 5;
  bool has_ae_rsp() const;
  private:
  bool _internal_has_ae_rsp() const;
  public:
  void clear_ae_rsp();
  const ::raft::AppendEntriesResponse& ae_rsp() const;
  PROTOBUF_NODISCARD ::raft::AppendEntriesResponse* release_ae_rsp();
  ::raft::AppendEntriesResponse* mutable_ae_rsp();
  void set_allocated_ae_rsp(::raft::AppendEntriesResponse* ae_rsp);
  private:
  const ::raft::AppendEntriesResponse& _internal_ae_rsp() const;
  ::raft::AppendEntriesResponse* _internal_mutable_ae_rsp();
  public:
  void unsafe_arena_set_allocated_ae_rsp(
      ::raft::AppendEntriesResponse* ae_rsp);
  ::raft::AppendEntriesResponse* unsafe_arena_release_ae_rsp();

  // .raft.MemberChangeRequest mc_req = 6;
  bool has_mc_req() const;
  private:
  bool _internal_has_mc_req() const;
  public:
  void clear_mc_req();
  const ::raft::MemberChangeRequest& mc_req() const;
  PROTOBUF_NODISCARD ::raft::MemberChangeRequest* release_mc_req();
  ::raft::MemberChangeRequest* mutable_mc_req();
  void set_allocated_mc_req(::raft::MemberChangeRequest* mc_req);
  private:
  const ::raft::MemberChangeRequest& _internal_mc_req() const;
  ::raft::MemberChangeRequest* _internal_mutable_mc_req();
  public:
  void unsafe_arena_set_allocated_mc_req(
      ::raft::MemberChangeRequest* mc_req);
  ::raft::MemberChangeRequest* unsafe_arena_release_mc_req();

  // .raft.MemberChangeResponse mc_rsp = 7;
  bool has_mc_rsp() const;
  private:
  bool _internal_has_mc_rsp() const;
  public:
  void clear_mc_rsp();
  const ::raft::MemberChangeResponse& mc_rsp() const;
  PROTOBUF_NODISCARD ::raft::MemberChangeResponse* release_mc_rsp();
  ::raft::MemberChangeResponse* mutable_mc_rsp();
  void set_allocated_mc_rsp(::raft::MemberChangeResponse* mc_rsp);
  private:
  const ::raft::MemberChangeResponse& _internal_mc_rsp() const;
  ::raft::MemberChangeResponse* _internal_mutable_mc_rsp();
  public:
  void unsafe_arena_set_allocated_mc_rsp(
      ::raft::MemberChangeResponse* mc_rsp);
  ::raft::MemberChangeResponse* unsafe_arena_release_mc_rsp();

  // .raft.MembersListRequest ml_req = 8;
  bool has_ml_req() const;
  private:
  bool _internal_has_ml_req() const;
  public:
  void clear_ml_req();
  const ::raft::MembersListRequest& ml_req() const;
  PROTOBUF_NODISCARD ::raft::MembersListRequest* release_ml_req();
  ::raft::MembersListRequest* mutable_ml_req();
  void set_allocated_ml_req(::raft::MembersListRequest* ml_req);
  private:
  const ::raft::MembersListRequest& _internal_ml_req() const;
  ::raft::MembersListRequest* _internal_mutable_ml_req();
  public:
  void unsafe_arena_set_allocated_ml_req(
      ::raft::MembersListRequest* ml_req);
  ::raft::MembersListRequest* unsafe_arena_release_ml_req();

  // .raft.MembersListResponse ml_rsp = 9;
  bool has_ml_rsp() const;
  private:
  bool _internal_has_ml_rsp() const;
  public:
  void clear_ml_rsp();
  const ::raft::MembersListResponse& ml_rsp() const;
  PROTOBUF_NODISCARD ::raft::MembersListResponse* release_ml_rsp();
  ::raft::MembersListResponse* mutable_ml_rsp();
  void set_allocated_ml_rsp(::raft::MembersListResponse* ml_rsp);
  private:
  const ::raft::MembersListResponse& _internal_ml_rsp() const;
  ::raft::MembersListResponse* _internal_mutable_ml_rsp();
  public:
  void unsafe_arena_set_allocated_ml_rsp(
      ::raft::MembersListResponse* ml_rsp);
  ::raft::MembersListResponse* unsafe_arena_release_ml_rsp();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:raft.RaftMessage)
 private:
  class _Internal;
  void set_has_vt_req();
  void set_has_vt_rsp();
  void set_has_ae_req();
  void set_has_ae_rsp();
  void set_has_mc_req();
  void set_has_mc_rsp();
  void set_has_ml_req();
  void set_has_ml_rsp();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t raftid_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::raft::VoteRequest* vt_req_;
    ::raft::VoteResponse* vt_rsp_;
    ::raft::AppendEntriesRequest* ae_req_;
    ::raft::AppendEntriesResponse* ae_rsp_;
    ::raft::MemberChangeRequest* mc_req_;
    ::raft::MemberChangeResponse* mc_rsp_;
    ::raft::MembersListRequest* ml_req_;
    ::raft::MembersListResponse* ml_rsp_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_raftmsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// .raft.RaftLogType type = 1;
inline void LogEntry::clear_type() {
  type_ = 0;
}
inline ::raft::RaftLogType LogEntry::_internal_type() const {
  return static_cast< ::raft::RaftLogType >(type_);
}
inline ::raft::RaftLogType LogEntry::type() const {
  // @@protoc_insertion_point(field_get:raft.LogEntry.type)
  return _internal_type();
}
inline void LogEntry::_internal_set_type(::raft::RaftLogType value) {
  
  type_ = value;
}
inline void LogEntry::set_type(::raft::RaftLogType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:raft.LogEntry.type)
}

// uint64 term = 2;
inline void LogEntry::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t LogEntry::_internal_term() const {
  return term_;
}
inline uint64_t LogEntry::term() const {
  // @@protoc_insertion_point(field_get:raft.LogEntry.term)
  return _internal_term();
}
inline void LogEntry::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void LogEntry::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.LogEntry.term)
}

// uint64 index = 3;
inline void LogEntry::clear_index() {
  index_ = uint64_t{0u};
}
inline uint64_t LogEntry::_internal_index() const {
  return index_;
}
inline uint64_t LogEntry::index() const {
  // @@protoc_insertion_point(field_get:raft.LogEntry.index)
  return _internal_index();
}
inline void LogEntry::_internal_set_index(uint64_t value) {
  
  index_ = value;
}
inline void LogEntry::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:raft.LogEntry.index)
}

// bytes data = 4;
inline void LogEntry::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& LogEntry::data() const {
  // @@protoc_insertion_point(field_get:raft.LogEntry.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft.LogEntry.data)
}
inline std::string* LogEntry::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:raft.LogEntry.data)
  return _s;
}
inline const std::string& LogEntry::_internal_data() const {
  return data_.Get();
}
inline void LogEntry::_internal_set_data(const std::string& value) {
  
  data_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_data() {
  
  return data_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_data() {
  // @@protoc_insertion_point(field_release:raft.LogEntry.data)
  return data_.Release();
}
inline void LogEntry::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft.LogEntry.data)
}

// -------------------------------------------------------------------

// Peer

// int32 raftid = 1;
inline void Peer::clear_raftid() {
  raftid_ = 0;
}
inline int32_t Peer::_internal_raftid() const {
  return raftid_;
}
inline int32_t Peer::raftid() const {
  // @@protoc_insertion_point(field_get:raft.Peer.raftid)
  return _internal_raftid();
}
inline void Peer::_internal_set_raftid(int32_t value) {
  
  raftid_ = value;
}
inline void Peer::set_raftid(int32_t value) {
  _internal_set_raftid(value);
  // @@protoc_insertion_point(field_set:raft.Peer.raftid)
}

// int32 nodeid = 2;
inline void Peer::clear_nodeid() {
  nodeid_ = 0;
}
inline int32_t Peer::_internal_nodeid() const {
  return nodeid_;
}
inline int32_t Peer::nodeid() const {
  // @@protoc_insertion_point(field_get:raft.Peer.nodeid)
  return _internal_nodeid();
}
inline void Peer::_internal_set_nodeid(int32_t value) {
  
  nodeid_ = value;
}
inline void Peer::set_nodeid(int32_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:raft.Peer.nodeid)
}

// string ip = 3;
inline void Peer::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Peer::ip() const {
  // @@protoc_insertion_point(field_get:raft.Peer.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:raft.Peer.ip)
}
inline std::string* Peer::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:raft.Peer.ip)
  return _s;
}
inline const std::string& Peer::_internal_ip() const {
  return ip_.Get();
}
inline void Peer::_internal_set_ip(const std::string& value) {
  
  ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Peer::_internal_mutable_ip() {
  
  return ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Peer::release_ip() {
  // @@protoc_insertion_point(field_release:raft.Peer.ip)
  return ip_.Release();
}
inline void Peer::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault()) {
    ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:raft.Peer.ip)
}

// uint32 port = 4;
inline void Peer::clear_port() {
  port_ = 0u;
}
inline uint32_t Peer::_internal_port() const {
  return port_;
}
inline uint32_t Peer::port() const {
  // @@protoc_insertion_point(field_get:raft.Peer.port)
  return _internal_port();
}
inline void Peer::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void Peer::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:raft.Peer.port)
}

// .raft.RaftState state = 5;
inline void Peer::clear_state() {
  state_ = 0;
}
inline ::raft::RaftState Peer::_internal_state() const {
  return static_cast< ::raft::RaftState >(state_);
}
inline ::raft::RaftState Peer::state() const {
  // @@protoc_insertion_point(field_get:raft.Peer.state)
  return _internal_state();
}
inline void Peer::_internal_set_state(::raft::RaftState value) {
  
  state_ = value;
}
inline void Peer::set_state(::raft::RaftState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:raft.Peer.state)
}

// -------------------------------------------------------------------

// VoteRequest

// uint64 term = 1;
inline void VoteRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t VoteRequest::_internal_term() const {
  return term_;
}
inline uint64_t VoteRequest::term() const {
  // @@protoc_insertion_point(field_get:raft.VoteRequest.term)
  return _internal_term();
}
inline void VoteRequest::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void VoteRequest::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.VoteRequest.term)
}

// uint64 candidate = 2;
inline void VoteRequest::clear_candidate() {
  candidate_ = uint64_t{0u};
}
inline uint64_t VoteRequest::_internal_candidate() const {
  return candidate_;
}
inline uint64_t VoteRequest::candidate() const {
  // @@protoc_insertion_point(field_get:raft.VoteRequest.candidate)
  return _internal_candidate();
}
inline void VoteRequest::_internal_set_candidate(uint64_t value) {
  
  candidate_ = value;
}
inline void VoteRequest::set_candidate(uint64_t value) {
  _internal_set_candidate(value);
  // @@protoc_insertion_point(field_set:raft.VoteRequest.candidate)
}

// uint64 last_term = 3;
inline void VoteRequest::clear_last_term() {
  last_term_ = uint64_t{0u};
}
inline uint64_t VoteRequest::_internal_last_term() const {
  return last_term_;
}
inline uint64_t VoteRequest::last_term() const {
  // @@protoc_insertion_point(field_get:raft.VoteRequest.last_term)
  return _internal_last_term();
}
inline void VoteRequest::_internal_set_last_term(uint64_t value) {
  
  last_term_ = value;
}
inline void VoteRequest::set_last_term(uint64_t value) {
  _internal_set_last_term(value);
  // @@protoc_insertion_point(field_set:raft.VoteRequest.last_term)
}

// uint64 last_index = 4;
inline void VoteRequest::clear_last_index() {
  last_index_ = uint64_t{0u};
}
inline uint64_t VoteRequest::_internal_last_index() const {
  return last_index_;
}
inline uint64_t VoteRequest::last_index() const {
  // @@protoc_insertion_point(field_get:raft.VoteRequest.last_index)
  return _internal_last_index();
}
inline void VoteRequest::_internal_set_last_index(uint64_t value) {
  
  last_index_ = value;
}
inline void VoteRequest::set_last_index(uint64_t value) {
  _internal_set_last_index(value);
  // @@protoc_insertion_point(field_set:raft.VoteRequest.last_index)
}

// -------------------------------------------------------------------

// VoteResponse

// uint64 term = 1;
inline void VoteResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t VoteResponse::_internal_term() const {
  return term_;
}
inline uint64_t VoteResponse::term() const {
  // @@protoc_insertion_point(field_get:raft.VoteResponse.term)
  return _internal_term();
}
inline void VoteResponse::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void VoteResponse::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.VoteResponse.term)
}

// int32 nodeid = 2;
inline void VoteResponse::clear_nodeid() {
  nodeid_ = 0;
}
inline int32_t VoteResponse::_internal_nodeid() const {
  return nodeid_;
}
inline int32_t VoteResponse::nodeid() const {
  // @@protoc_insertion_point(field_get:raft.VoteResponse.nodeid)
  return _internal_nodeid();
}
inline void VoteResponse::_internal_set_nodeid(int32_t value) {
  
  nodeid_ = value;
}
inline void VoteResponse::set_nodeid(int32_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:raft.VoteResponse.nodeid)
}

// bool agree = 3;
inline void VoteResponse::clear_agree() {
  agree_ = false;
}
inline bool VoteResponse::_internal_agree() const {
  return agree_;
}
inline bool VoteResponse::agree() const {
  // @@protoc_insertion_point(field_get:raft.VoteResponse.agree)
  return _internal_agree();
}
inline void VoteResponse::_internal_set_agree(bool value) {
  
  agree_ = value;
}
inline void VoteResponse::set_agree(bool value) {
  _internal_set_agree(value);
  // @@protoc_insertion_point(field_set:raft.VoteResponse.agree)
}

// -------------------------------------------------------------------

// AppendEntriesRequest

// int32 nodeid = 1;
inline void AppendEntriesRequest::clear_nodeid() {
  nodeid_ = 0;
}
inline int32_t AppendEntriesRequest::_internal_nodeid() const {
  return nodeid_;
}
inline int32_t AppendEntriesRequest::nodeid() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.nodeid)
  return _internal_nodeid();
}
inline void AppendEntriesRequest::_internal_set_nodeid(int32_t value) {
  
  nodeid_ = value;
}
inline void AppendEntriesRequest::set_nodeid(int32_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesRequest.nodeid)
}

// uint64 term = 2;
inline void AppendEntriesRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t AppendEntriesRequest::_internal_term() const {
  return term_;
}
inline uint64_t AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.term)
  return _internal_term();
}
inline void AppendEntriesRequest::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void AppendEntriesRequest::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesRequest.term)
}

// uint64 commit = 3;
inline void AppendEntriesRequest::clear_commit() {
  commit_ = uint64_t{0u};
}
inline uint64_t AppendEntriesRequest::_internal_commit() const {
  return commit_;
}
inline uint64_t AppendEntriesRequest::commit() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.commit)
  return _internal_commit();
}
inline void AppendEntriesRequest::_internal_set_commit(uint64_t value) {
  
  commit_ = value;
}
inline void AppendEntriesRequest::set_commit(uint64_t value) {
  _internal_set_commit(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesRequest.commit)
}

// uint64 prev_log_term = 4;
inline void AppendEntriesRequest::clear_prev_log_term() {
  prev_log_term_ = uint64_t{0u};
}
inline uint64_t AppendEntriesRequest::_internal_prev_log_term() const {
  return prev_log_term_;
}
inline uint64_t AppendEntriesRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntriesRequest::_internal_set_prev_log_term(uint64_t value) {
  
  prev_log_term_ = value;
}
inline void AppendEntriesRequest::set_prev_log_term(uint64_t value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesRequest.prev_log_term)
}

// uint64 prev_log_index = 5;
inline void AppendEntriesRequest::clear_prev_log_index() {
  prev_log_index_ = uint64_t{0u};
}
inline uint64_t AppendEntriesRequest::_internal_prev_log_index() const {
  return prev_log_index_;
}
inline uint64_t AppendEntriesRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.prev_log_index)
  return _internal_prev_log_index();
}
inline void AppendEntriesRequest::_internal_set_prev_log_index(uint64_t value) {
  
  prev_log_index_ = value;
}
inline void AppendEntriesRequest::set_prev_log_index(uint64_t value) {
  _internal_set_prev_log_index(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesRequest.prev_log_index)
}

// repeated .raft.LogEntry entries = 6;
inline int AppendEntriesRequest::_internal_entries_size() const {
  return entries_.size();
}
inline int AppendEntriesRequest::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline ::raft::LogEntry* AppendEntriesRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:raft.AppendEntriesRequest.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::LogEntry >*
AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:raft.AppendEntriesRequest.entries)
  return &entries_;
}
inline const ::raft::LogEntry& AppendEntriesRequest::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::raft::LogEntry& AppendEntriesRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesRequest.entries)
  return _internal_entries(index);
}
inline ::raft::LogEntry* AppendEntriesRequest::_internal_add_entries() {
  return entries_.Add();
}
inline ::raft::LogEntry* AppendEntriesRequest::add_entries() {
  ::raft::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:raft.AppendEntriesRequest.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::LogEntry >&
AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_list:raft.AppendEntriesRequest.entries)
  return entries_;
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// bool success = 1;
inline void AppendEntriesResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntriesResponse::_internal_success() const {
  return success_;
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesResponse.success)
  return _internal_success();
}
inline void AppendEntriesResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AppendEntriesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesResponse.success)
}

// int32 nodeid = 2;
inline void AppendEntriesResponse::clear_nodeid() {
  nodeid_ = 0;
}
inline int32_t AppendEntriesResponse::_internal_nodeid() const {
  return nodeid_;
}
inline int32_t AppendEntriesResponse::nodeid() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesResponse.nodeid)
  return _internal_nodeid();
}
inline void AppendEntriesResponse::_internal_set_nodeid(int32_t value) {
  
  nodeid_ = value;
}
inline void AppendEntriesResponse::set_nodeid(int32_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesResponse.nodeid)
}

// uint64 term = 3;
inline void AppendEntriesResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t AppendEntriesResponse::_internal_term() const {
  return term_;
}
inline uint64_t AppendEntriesResponse::term() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesResponse.term)
  return _internal_term();
}
inline void AppendEntriesResponse::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void AppendEntriesResponse::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesResponse.term)
}

// uint64 current_index = 4;
inline void AppendEntriesResponse::clear_current_index() {
  current_index_ = uint64_t{0u};
}
inline uint64_t AppendEntriesResponse::_internal_current_index() const {
  return current_index_;
}
inline uint64_t AppendEntriesResponse::current_index() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesResponse.current_index)
  return _internal_current_index();
}
inline void AppendEntriesResponse::_internal_set_current_index(uint64_t value) {
  
  current_index_ = value;
}
inline void AppendEntriesResponse::set_current_index(uint64_t value) {
  _internal_set_current_index(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesResponse.current_index)
}

// uint64 first_index = 5;
inline void AppendEntriesResponse::clear_first_index() {
  first_index_ = uint64_t{0u};
}
inline uint64_t AppendEntriesResponse::_internal_first_index() const {
  return first_index_;
}
inline uint64_t AppendEntriesResponse::first_index() const {
  // @@protoc_insertion_point(field_get:raft.AppendEntriesResponse.first_index)
  return _internal_first_index();
}
inline void AppendEntriesResponse::_internal_set_first_index(uint64_t value) {
  
  first_index_ = value;
}
inline void AppendEntriesResponse::set_first_index(uint64_t value) {
  _internal_set_first_index(value);
  // @@protoc_insertion_point(field_set:raft.AppendEntriesResponse.first_index)
}

// -------------------------------------------------------------------

// MemberChangeRequest

// .raft.RaftLogType type = 1;
inline void MemberChangeRequest::clear_type() {
  type_ = 0;
}
inline ::raft::RaftLogType MemberChangeRequest::_internal_type() const {
  return static_cast< ::raft::RaftLogType >(type_);
}
inline ::raft::RaftLogType MemberChangeRequest::type() const {
  // @@protoc_insertion_point(field_get:raft.MemberChangeRequest.type)
  return _internal_type();
}
inline void MemberChangeRequest::_internal_set_type(::raft::RaftLogType value) {
  
  type_ = value;
}
inline void MemberChangeRequest::set_type(::raft::RaftLogType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:raft.MemberChangeRequest.type)
}

// .raft.Peer peer = 2;
inline bool MemberChangeRequest::_internal_has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline bool MemberChangeRequest::has_peer() const {
  return _internal_has_peer();
}
inline void MemberChangeRequest::clear_peer() {
  if (GetArenaForAllocation() == nullptr && peer_ != nullptr) {
    delete peer_;
  }
  peer_ = nullptr;
}
inline const ::raft::Peer& MemberChangeRequest::_internal_peer() const {
  const ::raft::Peer* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::raft::Peer&>(
      ::raft::_Peer_default_instance_);
}
inline const ::raft::Peer& MemberChangeRequest::peer() const {
  // @@protoc_insertion_point(field_get:raft.MemberChangeRequest.peer)
  return _internal_peer();
}
inline void MemberChangeRequest::unsafe_arena_set_allocated_peer(
    ::raft::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.MemberChangeRequest.peer)
}
inline ::raft::Peer* MemberChangeRequest::release_peer() {
  
  ::raft::Peer* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::raft::Peer* MemberChangeRequest::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:raft.MemberChangeRequest.peer)
  
  ::raft::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::raft::Peer* MemberChangeRequest::_internal_mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::raft::Peer>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::raft::Peer* MemberChangeRequest::mutable_peer() {
  ::raft::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:raft.MemberChangeRequest.peer)
  return _msg;
}
inline void MemberChangeRequest::set_allocated_peer(::raft::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peer_;
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer);
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:raft.MemberChangeRequest.peer)
}

// -------------------------------------------------------------------

// MemberChangeResponse

// bool success = 1;
inline void MemberChangeResponse::clear_success() {
  success_ = false;
}
inline bool MemberChangeResponse::_internal_success() const {
  return success_;
}
inline bool MemberChangeResponse::success() const {
  // @@protoc_insertion_point(field_get:raft.MemberChangeResponse.success)
  return _internal_success();
}
inline void MemberChangeResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void MemberChangeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:raft.MemberChangeResponse.success)
}

// uint64 term = 2;
inline void MemberChangeResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t MemberChangeResponse::_internal_term() const {
  return term_;
}
inline uint64_t MemberChangeResponse::term() const {
  // @@protoc_insertion_point(field_get:raft.MemberChangeResponse.term)
  return _internal_term();
}
inline void MemberChangeResponse::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void MemberChangeResponse::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.MemberChangeResponse.term)
}

// .raft.Peer peer = 3;
inline bool MemberChangeResponse::_internal_has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline bool MemberChangeResponse::has_peer() const {
  return _internal_has_peer();
}
inline void MemberChangeResponse::clear_peer() {
  if (GetArenaForAllocation() == nullptr && peer_ != nullptr) {
    delete peer_;
  }
  peer_ = nullptr;
}
inline const ::raft::Peer& MemberChangeResponse::_internal_peer() const {
  const ::raft::Peer* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::raft::Peer&>(
      ::raft::_Peer_default_instance_);
}
inline const ::raft::Peer& MemberChangeResponse::peer() const {
  // @@protoc_insertion_point(field_get:raft.MemberChangeResponse.peer)
  return _internal_peer();
}
inline void MemberChangeResponse::unsafe_arena_set_allocated_peer(
    ::raft::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.MemberChangeResponse.peer)
}
inline ::raft::Peer* MemberChangeResponse::release_peer() {
  
  ::raft::Peer* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::raft::Peer* MemberChangeResponse::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:raft.MemberChangeResponse.peer)
  
  ::raft::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::raft::Peer* MemberChangeResponse::_internal_mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::raft::Peer>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::raft::Peer* MemberChangeResponse::mutable_peer() {
  ::raft::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:raft.MemberChangeResponse.peer)
  return _msg;
}
inline void MemberChangeResponse::set_allocated_peer(::raft::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete peer_;
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer);
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:raft.MemberChangeResponse.peer)
}

// -------------------------------------------------------------------

// MembersListRequest

// uint64 raftid = 1;
inline void MembersListRequest::clear_raftid() {
  raftid_ = uint64_t{0u};
}
inline uint64_t MembersListRequest::_internal_raftid() const {
  return raftid_;
}
inline uint64_t MembersListRequest::raftid() const {
  // @@protoc_insertion_point(field_get:raft.MembersListRequest.raftid)
  return _internal_raftid();
}
inline void MembersListRequest::_internal_set_raftid(uint64_t value) {
  
  raftid_ = value;
}
inline void MembersListRequest::set_raftid(uint64_t value) {
  _internal_set_raftid(value);
  // @@protoc_insertion_point(field_set:raft.MembersListRequest.raftid)
}

// -------------------------------------------------------------------

// MembersListResponse

// bool success = 1;
inline void MembersListResponse::clear_success() {
  success_ = false;
}
inline bool MembersListResponse::_internal_success() const {
  return success_;
}
inline bool MembersListResponse::success() const {
  // @@protoc_insertion_point(field_get:raft.MembersListResponse.success)
  return _internal_success();
}
inline void MembersListResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void MembersListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:raft.MembersListResponse.success)
}

// uint64 term = 2;
inline void MembersListResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t MembersListResponse::_internal_term() const {
  return term_;
}
inline uint64_t MembersListResponse::term() const {
  // @@protoc_insertion_point(field_get:raft.MembersListResponse.term)
  return _internal_term();
}
inline void MembersListResponse::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void MembersListResponse::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:raft.MembersListResponse.term)
}

// uint64 raftid = 3;
inline void MembersListResponse::clear_raftid() {
  raftid_ = uint64_t{0u};
}
inline uint64_t MembersListResponse::_internal_raftid() const {
  return raftid_;
}
inline uint64_t MembersListResponse::raftid() const {
  // @@protoc_insertion_point(field_get:raft.MembersListResponse.raftid)
  return _internal_raftid();
}
inline void MembersListResponse::_internal_set_raftid(uint64_t value) {
  
  raftid_ = value;
}
inline void MembersListResponse::set_raftid(uint64_t value) {
  _internal_set_raftid(value);
  // @@protoc_insertion_point(field_set:raft.MembersListResponse.raftid)
}

// repeated .raft.Peer peers = 4;
inline int MembersListResponse::_internal_peers_size() const {
  return peers_.size();
}
inline int MembersListResponse::peers_size() const {
  return _internal_peers_size();
}
inline void MembersListResponse::clear_peers() {
  peers_.Clear();
}
inline ::raft::Peer* MembersListResponse::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:raft.MembersListResponse.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::Peer >*
MembersListResponse::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:raft.MembersListResponse.peers)
  return &peers_;
}
inline const ::raft::Peer& MembersListResponse::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::raft::Peer& MembersListResponse::peers(int index) const {
  // @@protoc_insertion_point(field_get:raft.MembersListResponse.peers)
  return _internal_peers(index);
}
inline ::raft::Peer* MembersListResponse::_internal_add_peers() {
  return peers_.Add();
}
inline ::raft::Peer* MembersListResponse::add_peers() {
  ::raft::Peer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:raft.MembersListResponse.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::raft::Peer >&
MembersListResponse::peers() const {
  // @@protoc_insertion_point(field_list:raft.MembersListResponse.peers)
  return peers_;
}

// -------------------------------------------------------------------

// RaftMessage

// uint32 raftid = 1;
inline void RaftMessage::clear_raftid() {
  raftid_ = 0u;
}
inline uint32_t RaftMessage::_internal_raftid() const {
  return raftid_;
}
inline uint32_t RaftMessage::raftid() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.raftid)
  return _internal_raftid();
}
inline void RaftMessage::_internal_set_raftid(uint32_t value) {
  
  raftid_ = value;
}
inline void RaftMessage::set_raftid(uint32_t value) {
  _internal_set_raftid(value);
  // @@protoc_insertion_point(field_set:raft.RaftMessage.raftid)
}

// .raft.VoteRequest vt_req = 2;
inline bool RaftMessage::_internal_has_vt_req() const {
  return msg_case() == kVtReq;
}
inline bool RaftMessage::has_vt_req() const {
  return _internal_has_vt_req();
}
inline void RaftMessage::set_has_vt_req() {
  _oneof_case_[0] = kVtReq;
}
inline void RaftMessage::clear_vt_req() {
  if (_internal_has_vt_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.vt_req_;
    }
    clear_has_msg();
  }
}
inline ::raft::VoteRequest* RaftMessage::release_vt_req() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.vt_req)
  if (_internal_has_vt_req()) {
    clear_has_msg();
    ::raft::VoteRequest* temp = msg_.vt_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.vt_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::VoteRequest& RaftMessage::_internal_vt_req() const {
  return _internal_has_vt_req()
      ? *msg_.vt_req_
      : reinterpret_cast< ::raft::VoteRequest&>(::raft::_VoteRequest_default_instance_);
}
inline const ::raft::VoteRequest& RaftMessage::vt_req() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.vt_req)
  return _internal_vt_req();
}
inline ::raft::VoteRequest* RaftMessage::unsafe_arena_release_vt_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.vt_req)
  if (_internal_has_vt_req()) {
    clear_has_msg();
    ::raft::VoteRequest* temp = msg_.vt_req_;
    msg_.vt_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_vt_req(::raft::VoteRequest* vt_req) {
  clear_msg();
  if (vt_req) {
    set_has_vt_req();
    msg_.vt_req_ = vt_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.vt_req)
}
inline ::raft::VoteRequest* RaftMessage::_internal_mutable_vt_req() {
  if (!_internal_has_vt_req()) {
    clear_msg();
    set_has_vt_req();
    msg_.vt_req_ = CreateMaybeMessage< ::raft::VoteRequest >(GetArenaForAllocation());
  }
  return msg_.vt_req_;
}
inline ::raft::VoteRequest* RaftMessage::mutable_vt_req() {
  ::raft::VoteRequest* _msg = _internal_mutable_vt_req();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.vt_req)
  return _msg;
}

// .raft.VoteResponse vt_rsp = 3;
inline bool RaftMessage::_internal_has_vt_rsp() const {
  return msg_case() == kVtRsp;
}
inline bool RaftMessage::has_vt_rsp() const {
  return _internal_has_vt_rsp();
}
inline void RaftMessage::set_has_vt_rsp() {
  _oneof_case_[0] = kVtRsp;
}
inline void RaftMessage::clear_vt_rsp() {
  if (_internal_has_vt_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.vt_rsp_;
    }
    clear_has_msg();
  }
}
inline ::raft::VoteResponse* RaftMessage::release_vt_rsp() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.vt_rsp)
  if (_internal_has_vt_rsp()) {
    clear_has_msg();
    ::raft::VoteResponse* temp = msg_.vt_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.vt_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::VoteResponse& RaftMessage::_internal_vt_rsp() const {
  return _internal_has_vt_rsp()
      ? *msg_.vt_rsp_
      : reinterpret_cast< ::raft::VoteResponse&>(::raft::_VoteResponse_default_instance_);
}
inline const ::raft::VoteResponse& RaftMessage::vt_rsp() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.vt_rsp)
  return _internal_vt_rsp();
}
inline ::raft::VoteResponse* RaftMessage::unsafe_arena_release_vt_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.vt_rsp)
  if (_internal_has_vt_rsp()) {
    clear_has_msg();
    ::raft::VoteResponse* temp = msg_.vt_rsp_;
    msg_.vt_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_vt_rsp(::raft::VoteResponse* vt_rsp) {
  clear_msg();
  if (vt_rsp) {
    set_has_vt_rsp();
    msg_.vt_rsp_ = vt_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.vt_rsp)
}
inline ::raft::VoteResponse* RaftMessage::_internal_mutable_vt_rsp() {
  if (!_internal_has_vt_rsp()) {
    clear_msg();
    set_has_vt_rsp();
    msg_.vt_rsp_ = CreateMaybeMessage< ::raft::VoteResponse >(GetArenaForAllocation());
  }
  return msg_.vt_rsp_;
}
inline ::raft::VoteResponse* RaftMessage::mutable_vt_rsp() {
  ::raft::VoteResponse* _msg = _internal_mutable_vt_rsp();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.vt_rsp)
  return _msg;
}

// .raft.AppendEntriesRequest ae_req = 4;
inline bool RaftMessage::_internal_has_ae_req() const {
  return msg_case() == kAeReq;
}
inline bool RaftMessage::has_ae_req() const {
  return _internal_has_ae_req();
}
inline void RaftMessage::set_has_ae_req() {
  _oneof_case_[0] = kAeReq;
}
inline void RaftMessage::clear_ae_req() {
  if (_internal_has_ae_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.ae_req_;
    }
    clear_has_msg();
  }
}
inline ::raft::AppendEntriesRequest* RaftMessage::release_ae_req() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.ae_req)
  if (_internal_has_ae_req()) {
    clear_has_msg();
    ::raft::AppendEntriesRequest* temp = msg_.ae_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ae_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::AppendEntriesRequest& RaftMessage::_internal_ae_req() const {
  return _internal_has_ae_req()
      ? *msg_.ae_req_
      : reinterpret_cast< ::raft::AppendEntriesRequest&>(::raft::_AppendEntriesRequest_default_instance_);
}
inline const ::raft::AppendEntriesRequest& RaftMessage::ae_req() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.ae_req)
  return _internal_ae_req();
}
inline ::raft::AppendEntriesRequest* RaftMessage::unsafe_arena_release_ae_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.ae_req)
  if (_internal_has_ae_req()) {
    clear_has_msg();
    ::raft::AppendEntriesRequest* temp = msg_.ae_req_;
    msg_.ae_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_ae_req(::raft::AppendEntriesRequest* ae_req) {
  clear_msg();
  if (ae_req) {
    set_has_ae_req();
    msg_.ae_req_ = ae_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.ae_req)
}
inline ::raft::AppendEntriesRequest* RaftMessage::_internal_mutable_ae_req() {
  if (!_internal_has_ae_req()) {
    clear_msg();
    set_has_ae_req();
    msg_.ae_req_ = CreateMaybeMessage< ::raft::AppendEntriesRequest >(GetArenaForAllocation());
  }
  return msg_.ae_req_;
}
inline ::raft::AppendEntriesRequest* RaftMessage::mutable_ae_req() {
  ::raft::AppendEntriesRequest* _msg = _internal_mutable_ae_req();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.ae_req)
  return _msg;
}

// .raft.AppendEntriesResponse ae_rsp = 5;
inline bool RaftMessage::_internal_has_ae_rsp() const {
  return msg_case() == kAeRsp;
}
inline bool RaftMessage::has_ae_rsp() const {
  return _internal_has_ae_rsp();
}
inline void RaftMessage::set_has_ae_rsp() {
  _oneof_case_[0] = kAeRsp;
}
inline void RaftMessage::clear_ae_rsp() {
  if (_internal_has_ae_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.ae_rsp_;
    }
    clear_has_msg();
  }
}
inline ::raft::AppendEntriesResponse* RaftMessage::release_ae_rsp() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.ae_rsp)
  if (_internal_has_ae_rsp()) {
    clear_has_msg();
    ::raft::AppendEntriesResponse* temp = msg_.ae_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ae_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::AppendEntriesResponse& RaftMessage::_internal_ae_rsp() const {
  return _internal_has_ae_rsp()
      ? *msg_.ae_rsp_
      : reinterpret_cast< ::raft::AppendEntriesResponse&>(::raft::_AppendEntriesResponse_default_instance_);
}
inline const ::raft::AppendEntriesResponse& RaftMessage::ae_rsp() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.ae_rsp)
  return _internal_ae_rsp();
}
inline ::raft::AppendEntriesResponse* RaftMessage::unsafe_arena_release_ae_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.ae_rsp)
  if (_internal_has_ae_rsp()) {
    clear_has_msg();
    ::raft::AppendEntriesResponse* temp = msg_.ae_rsp_;
    msg_.ae_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_ae_rsp(::raft::AppendEntriesResponse* ae_rsp) {
  clear_msg();
  if (ae_rsp) {
    set_has_ae_rsp();
    msg_.ae_rsp_ = ae_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.ae_rsp)
}
inline ::raft::AppendEntriesResponse* RaftMessage::_internal_mutable_ae_rsp() {
  if (!_internal_has_ae_rsp()) {
    clear_msg();
    set_has_ae_rsp();
    msg_.ae_rsp_ = CreateMaybeMessage< ::raft::AppendEntriesResponse >(GetArenaForAllocation());
  }
  return msg_.ae_rsp_;
}
inline ::raft::AppendEntriesResponse* RaftMessage::mutable_ae_rsp() {
  ::raft::AppendEntriesResponse* _msg = _internal_mutable_ae_rsp();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.ae_rsp)
  return _msg;
}

// .raft.MemberChangeRequest mc_req = 6;
inline bool RaftMessage::_internal_has_mc_req() const {
  return msg_case() == kMcReq;
}
inline bool RaftMessage::has_mc_req() const {
  return _internal_has_mc_req();
}
inline void RaftMessage::set_has_mc_req() {
  _oneof_case_[0] = kMcReq;
}
inline void RaftMessage::clear_mc_req() {
  if (_internal_has_mc_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.mc_req_;
    }
    clear_has_msg();
  }
}
inline ::raft::MemberChangeRequest* RaftMessage::release_mc_req() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.mc_req)
  if (_internal_has_mc_req()) {
    clear_has_msg();
    ::raft::MemberChangeRequest* temp = msg_.mc_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.mc_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::MemberChangeRequest& RaftMessage::_internal_mc_req() const {
  return _internal_has_mc_req()
      ? *msg_.mc_req_
      : reinterpret_cast< ::raft::MemberChangeRequest&>(::raft::_MemberChangeRequest_default_instance_);
}
inline const ::raft::MemberChangeRequest& RaftMessage::mc_req() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.mc_req)
  return _internal_mc_req();
}
inline ::raft::MemberChangeRequest* RaftMessage::unsafe_arena_release_mc_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.mc_req)
  if (_internal_has_mc_req()) {
    clear_has_msg();
    ::raft::MemberChangeRequest* temp = msg_.mc_req_;
    msg_.mc_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_mc_req(::raft::MemberChangeRequest* mc_req) {
  clear_msg();
  if (mc_req) {
    set_has_mc_req();
    msg_.mc_req_ = mc_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.mc_req)
}
inline ::raft::MemberChangeRequest* RaftMessage::_internal_mutable_mc_req() {
  if (!_internal_has_mc_req()) {
    clear_msg();
    set_has_mc_req();
    msg_.mc_req_ = CreateMaybeMessage< ::raft::MemberChangeRequest >(GetArenaForAllocation());
  }
  return msg_.mc_req_;
}
inline ::raft::MemberChangeRequest* RaftMessage::mutable_mc_req() {
  ::raft::MemberChangeRequest* _msg = _internal_mutable_mc_req();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.mc_req)
  return _msg;
}

// .raft.MemberChangeResponse mc_rsp = 7;
inline bool RaftMessage::_internal_has_mc_rsp() const {
  return msg_case() == kMcRsp;
}
inline bool RaftMessage::has_mc_rsp() const {
  return _internal_has_mc_rsp();
}
inline void RaftMessage::set_has_mc_rsp() {
  _oneof_case_[0] = kMcRsp;
}
inline void RaftMessage::clear_mc_rsp() {
  if (_internal_has_mc_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.mc_rsp_;
    }
    clear_has_msg();
  }
}
inline ::raft::MemberChangeResponse* RaftMessage::release_mc_rsp() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.mc_rsp)
  if (_internal_has_mc_rsp()) {
    clear_has_msg();
    ::raft::MemberChangeResponse* temp = msg_.mc_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.mc_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::MemberChangeResponse& RaftMessage::_internal_mc_rsp() const {
  return _internal_has_mc_rsp()
      ? *msg_.mc_rsp_
      : reinterpret_cast< ::raft::MemberChangeResponse&>(::raft::_MemberChangeResponse_default_instance_);
}
inline const ::raft::MemberChangeResponse& RaftMessage::mc_rsp() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.mc_rsp)
  return _internal_mc_rsp();
}
inline ::raft::MemberChangeResponse* RaftMessage::unsafe_arena_release_mc_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.mc_rsp)
  if (_internal_has_mc_rsp()) {
    clear_has_msg();
    ::raft::MemberChangeResponse* temp = msg_.mc_rsp_;
    msg_.mc_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_mc_rsp(::raft::MemberChangeResponse* mc_rsp) {
  clear_msg();
  if (mc_rsp) {
    set_has_mc_rsp();
    msg_.mc_rsp_ = mc_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.mc_rsp)
}
inline ::raft::MemberChangeResponse* RaftMessage::_internal_mutable_mc_rsp() {
  if (!_internal_has_mc_rsp()) {
    clear_msg();
    set_has_mc_rsp();
    msg_.mc_rsp_ = CreateMaybeMessage< ::raft::MemberChangeResponse >(GetArenaForAllocation());
  }
  return msg_.mc_rsp_;
}
inline ::raft::MemberChangeResponse* RaftMessage::mutable_mc_rsp() {
  ::raft::MemberChangeResponse* _msg = _internal_mutable_mc_rsp();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.mc_rsp)
  return _msg;
}

// .raft.MembersListRequest ml_req = 8;
inline bool RaftMessage::_internal_has_ml_req() const {
  return msg_case() == kMlReq;
}
inline bool RaftMessage::has_ml_req() const {
  return _internal_has_ml_req();
}
inline void RaftMessage::set_has_ml_req() {
  _oneof_case_[0] = kMlReq;
}
inline void RaftMessage::clear_ml_req() {
  if (_internal_has_ml_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.ml_req_;
    }
    clear_has_msg();
  }
}
inline ::raft::MembersListRequest* RaftMessage::release_ml_req() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.ml_req)
  if (_internal_has_ml_req()) {
    clear_has_msg();
    ::raft::MembersListRequest* temp = msg_.ml_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ml_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::MembersListRequest& RaftMessage::_internal_ml_req() const {
  return _internal_has_ml_req()
      ? *msg_.ml_req_
      : reinterpret_cast< ::raft::MembersListRequest&>(::raft::_MembersListRequest_default_instance_);
}
inline const ::raft::MembersListRequest& RaftMessage::ml_req() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.ml_req)
  return _internal_ml_req();
}
inline ::raft::MembersListRequest* RaftMessage::unsafe_arena_release_ml_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.ml_req)
  if (_internal_has_ml_req()) {
    clear_has_msg();
    ::raft::MembersListRequest* temp = msg_.ml_req_;
    msg_.ml_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_ml_req(::raft::MembersListRequest* ml_req) {
  clear_msg();
  if (ml_req) {
    set_has_ml_req();
    msg_.ml_req_ = ml_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.ml_req)
}
inline ::raft::MembersListRequest* RaftMessage::_internal_mutable_ml_req() {
  if (!_internal_has_ml_req()) {
    clear_msg();
    set_has_ml_req();
    msg_.ml_req_ = CreateMaybeMessage< ::raft::MembersListRequest >(GetArenaForAllocation());
  }
  return msg_.ml_req_;
}
inline ::raft::MembersListRequest* RaftMessage::mutable_ml_req() {
  ::raft::MembersListRequest* _msg = _internal_mutable_ml_req();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.ml_req)
  return _msg;
}

// .raft.MembersListResponse ml_rsp = 9;
inline bool RaftMessage::_internal_has_ml_rsp() const {
  return msg_case() == kMlRsp;
}
inline bool RaftMessage::has_ml_rsp() const {
  return _internal_has_ml_rsp();
}
inline void RaftMessage::set_has_ml_rsp() {
  _oneof_case_[0] = kMlRsp;
}
inline void RaftMessage::clear_ml_rsp() {
  if (_internal_has_ml_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.ml_rsp_;
    }
    clear_has_msg();
  }
}
inline ::raft::MembersListResponse* RaftMessage::release_ml_rsp() {
  // @@protoc_insertion_point(field_release:raft.RaftMessage.ml_rsp)
  if (_internal_has_ml_rsp()) {
    clear_has_msg();
    ::raft::MembersListResponse* temp = msg_.ml_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.ml_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::raft::MembersListResponse& RaftMessage::_internal_ml_rsp() const {
  return _internal_has_ml_rsp()
      ? *msg_.ml_rsp_
      : reinterpret_cast< ::raft::MembersListResponse&>(::raft::_MembersListResponse_default_instance_);
}
inline const ::raft::MembersListResponse& RaftMessage::ml_rsp() const {
  // @@protoc_insertion_point(field_get:raft.RaftMessage.ml_rsp)
  return _internal_ml_rsp();
}
inline ::raft::MembersListResponse* RaftMessage::unsafe_arena_release_ml_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:raft.RaftMessage.ml_rsp)
  if (_internal_has_ml_rsp()) {
    clear_has_msg();
    ::raft::MembersListResponse* temp = msg_.ml_rsp_;
    msg_.ml_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftMessage::unsafe_arena_set_allocated_ml_rsp(::raft::MembersListResponse* ml_rsp) {
  clear_msg();
  if (ml_rsp) {
    set_has_ml_rsp();
    msg_.ml_rsp_ = ml_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:raft.RaftMessage.ml_rsp)
}
inline ::raft::MembersListResponse* RaftMessage::_internal_mutable_ml_rsp() {
  if (!_internal_has_ml_rsp()) {
    clear_msg();
    set_has_ml_rsp();
    msg_.ml_rsp_ = CreateMaybeMessage< ::raft::MembersListResponse >(GetArenaForAllocation());
  }
  return msg_.ml_rsp_;
}
inline ::raft::MembersListResponse* RaftMessage::mutable_ml_rsp() {
  ::raft::MembersListResponse* _msg = _internal_mutable_ml_rsp();
  // @@protoc_insertion_point(field_mutable:raft.RaftMessage.ml_rsp)
  return _msg;
}

inline bool RaftMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void RaftMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline RaftMessage::MsgCase RaftMessage::msg_case() const {
  return RaftMessage::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace raft

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::raft::RaftState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::raft::RaftState>() {
  return ::raft::RaftState_descriptor();
}
template <> struct is_proto_enum< ::raft::RaftLogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::raft::RaftLogType>() {
  return ::raft::RaftLogType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_raftmsg_2eproto
